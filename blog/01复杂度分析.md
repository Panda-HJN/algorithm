# 复杂度分析

### 大O表示法
因为对程序运行结果的测试结果非常依赖于测试环境和数据规模。（小霸王和i9 百条数据和千万条数据）   
所以需要手段来粗略地估计程序执行效率的方法
假设每行执行时间相同 设为 1单位的unit_time。   
```
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }

```
这段代码的 执行时间 为 1+1+2n  即 T(time) = (2+2n)*unit_time   

```
 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```
同理 这段代码执行时间为 (3+2n+ 2n^2 )unit_time    

以上规律总结为 

T(n) = O(f(n))   

T(n)  表示代码执行的时间；n 表示数据总量。n越大表示数据总量越大。   
大O时间复杂度表示法表示的是代码执行时间随数据规模增长的变化趋势。   
上面两段时间复杂度用大O法表示为T(n) = O(n)； T(n) = O(n2)  (只关心最大的阶数)


### 一些方法
1. 只关注循环执行次数最多的一段代码  
2. 总复杂度等于量级最大的那段代码的复杂度 
3. 嵌套循环的复杂度等于嵌套内外代码复杂度的乘积

### 一些例子

1. O(1)
```
 int i = 8;
 int j = 6;
 int sum = i + j;

```

2. O(logn)、O(nlogn)   
对数阶时间复杂度非常常见，同时也难分析
```
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
// i 1 2 4 8 16 ......
```
i 的变化是个等比数列 
O(log3n)
忽略常数，就可以把所有对数阶的时间复杂度都记为 O(logn)。

3.   O(m+n)、O(m*n)  
代码复杂度由多块代码来决定
```
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}

```
这段代码由 m n两个值来影响数据规模 。在无法事先知道 m n 量级情况下