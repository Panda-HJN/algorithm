# 线性表 

连续的,有方向的，拥有连续的内存空间，有相同类型的数据结构

 正是因为这种特点在 “随机访问”这一项上有着极高的效率。
但这也意味着对于插入 删除等操作，要做大量的数据搬移工作。


- 线性表
数组 队列 链表 栈
- 非线性表
树 图 堆

## 数组
就是那玩意呗 
## 链表
通过指针将零散 的内存块连接起来
每个内存块是个节点
每个节点都要记录下一个节点的地址（后继指针 next）
链表内插入删除 只需要修改 后继指针就可以了



单链表 有头节点 头节点是基地址 由此遍历整个链表   尾节点 后继指针是 null

循环链表  没头没尾是个环  哪些数据是环形结构的 可以考虑用这

 双链表 每个节点处理后继指针 还有前驱指针  指向前一个节点。
 和单链表比每个节点多消耗了些空间来放置前驱指针。但是却多了一个从另一个方向遍历的特点。


## 链表和数组的区别

链表适合插入、删除，时间复杂度 O(1)； 但是具体访问某个节点则需要从头开始遍历
数组支持随机访问 根据下表随机访问 时间复杂度为 O(1) 二分法查找



## 为什么数组要从 0 开始编号，而不是从 1 ？
数组是种线性表，是连续有方向的数据结构。
从内存模型上看
一个数组占据一坨连续的内存。这坨内存有个起始内存地址。
数组的下标实质上是距离内存块起始地址的 偏移量
每次用下标来访问数组元素时
每次寻址
从0 开始 直接使用下标表示的偏移量就行了  
从1开始  都会**额外做一次 减1 的减法**。
数组作为最基础的数据结构要优化到极致。

所以数组要从 0开始编号~~~~~ 拉拉拉拉啊
```js
class nodeInLinkedList sadasfd{

}
class linkedList{}
```
## 双链表比单链表好在哪?(或者说什么情境下更好)

链表中删除一个数据实际上是
1. 删除 **节点值等于给定值**的节点（通过值来查找？） 方法：从头开始遍历
2. 删除**给定指针指向的**节点    （由指针来删？）

## 简单的缓存淘汰
1. 维护一个有序单链表，越靠近起始点是越旧的。
2. 新数据来了，从起始点开始遍历。发现已经存在了，把已存在的删掉，在尾部塞进去。
3. 如果不存在，看缓存单链表是否满了，满了就删最老的，把新的插尾巴上 
4. 没满就直接插尾巴上


## 待解决问题，没搞明白
1. 循环链表，双向循环链表用在什么场景？
2. 双链表 比 单链表好在哪?（前驱指针能干啥）